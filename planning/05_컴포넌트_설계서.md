# 컴포넌트 설계서

## JetRover AI 아키텍처

**최종 통합 기술 설계 문서**  
버전 3.0 | 2026년 2월

---

## AI 모델 스택

### 모델별 실행환경 및 정밀도

| 모델 | 실행환경 | RAM | 지연 | 전력 | 핵심 결정 |
|------|----------|-----|------|------|-----------|
| Porcupine | CPU (C SDK) | 30MB | ~10ms | ~0.1W | 웨이크워드. 상시 실행. PyTorch 불필요 |
| Silero VAD | CPU (sherpa-onnx) | 80MB | ~50ms | ~0.2W | GPU 전환 시 50~60% 오히려 느려짐 확인. CPU 확정 |
| moonshine-tiny-ko | GPU (sherpa-onnx) | ~150MB | ~250ms | ~1W burst | BF16 convolution frontend → CPU ORT에서 FP32 강등 → 정확도 저하 |
| YOLO11n TRT | GPU FP16 | 400MB | ~50ms | ~4W | FP16 확정. INT8 금지 (Orin Nano에서 이득 없고 정확도 저하) |
| KoSimCSE ONNX | CPU FP32 | 450MB | ~80ms | ~0.5W | 인텐트 분류. FP32 고정 (FP16 변환 시 CPU ORT 동작 불가) |
| Piper TTS 한국어 | CPU FP32 | 180MB | ~120ms | ~0.5W | RTF 0.1~0.3으로 GPU 불필요. VITS ONNX |
| RapidOCR ONNX | CPU FP32 | 300MB peak | ~400ms | ~1W burst | GPU 지원 공식 포기 (메인테이너 확인) |
| Qwen2.5-1.5B GGUF | GPU (-ngl 99) | 1.35GB | TTFT ~450ms | ~5W | 정지 시만 실행 (이동 중 15W 초과). MAX_HISTORY=3턴 |
| moondream2 GGUF | GPU (-ngl 99) | 1.75GB | TTFT 2.5~3.5s | ~7W | mmproj f16 고정 필수 (q4 양자화 시 VQA 정확도 저하) |

### 주의사항

⚠️ **moonshine-tiny-ko**: BF16 convolution frontend가 설계 의도. CPU ORT는 BF16을 FP32로 강등 → 정확도 저하. sherpa-onnx GPU 빌드 필수.

⚠️ **YOLO11n INT8 금지**: Jetson Orin Nano에서 INT8이 FP16 대비 속도·정확도 모두 이득 없음 (실측 확인).

⚠️ **moondream2 mmproj**: 반드시 f16 유지. q4 양자화 시 이미지 인식 정확도 눈에 띄게 저하.

---

## 음성 처리 파이프라인

```
Porcupine (C SDK) → sherpa-onnx VAD → sherpa-onnx STT (moonshine GPU) 
→ KoSimCSE → Intent Router → llama.cpp LLM → sherpa-onnx TTS (Piper)
```

### 컴포넌트 상세

| 단계 | 입력 | 출력 | 처리 시간 | 비고 |
|------|------|------|-----------|------|
| Porcupine | 오디오 스트림 | 웨이크워드 트리거 | ~10ms | 상시 대기 |
| VAD | 오디오 스트림 | 발화 구간 | ~50ms | 에너지 기반 |
| STT | 발화 오디오 | 텍스트 | ~250ms | moonshine-tiny-ko |
| Intent | 텍스트 | 의도 클래스 | ~80ms | KoSimCSE |
| LLM | 의도 + 컨텍스트 | 응답 텍스트 | ~450ms TTFT | Qwen2.5-1.5B |
| TTS | 응답 텍스트 | 오디오 | ~120ms | Piper |

---

## ROS2 패키지 구성

| 패키지 | 역할 | RAM | CPU | 설정 요점 |
|--------|------|-----|-----|-----------|
| slam_toolbox | 맵핑/로컬라이제이션 | 200~300MB | 0.5~2코어 | 운용 시 localization 모드 |
| Nav2 (Composition) | A* 전역계획 + DWB 제어 | 150~180MB | 0.5~2코어 | use_composition:=True 필수 |
| MoveIt2 + trac-ik | 6DOF IK + 경로계획 | ~450MB | 1~2코어 | solve_type: Speed, timeout: 0.05s |
| ros2_control | 관절 상태 관리 | 150MB | 0.5코어 | update_rate: 50Hz |
| hiwonder_bridge | MoveIt ↔ Hiwonder 변환 | 40MB | 0.1코어 | JointTrajectory → ServosPosition 변환 |
| robot_state_publisher | URDF → TF | 50MB | 0.2코어 | joint_state_broadcaster 연동 |
| robot_localization | EKF (IMU + odom 융합) | 60MB | 0.2코어 | 50Hz |
| pan_tilt_controller | 칩메라 팬틸트 독립 제어 | 30MB | 0.1코어 | MoveIt 제외, 토픽 기반 |
| RPLIDAR A1 드라이버 | LaserScan 발행 | 70MB | 0.3코어 | 15Hz, /scan 토픽 |
| DaBai DCW 드라이버 | RGB-D 스트림 | 100MB | 0.3코어 | YOLO 입력 + 깊이 추정용 |

### Nav2 Composition 설정
```yaml
# 필수 설정
use_composition: True  # 메모리 70%, CPU 13% 절감
```

ℹ️ Nav2 use_composition:=True 필수. 다중 프로세스 대비 메모리 70%, CPU 13% 절감.

⚠️ hiwonder_bridge는 직접 개발 필요. MoveIt2 FollowJointTrajectory action → Hiwonder /bus_servo/set_position 토픽 변환.

---

## MoveIt2 구성

### 플래닝 그룹

| 그룹명 | 관절 | 엔드이펙터 | 비고 |
|--------|------|------------|------|
| arm | joint1~joint6 (HTD-35H3 ×6) | gripper_link | 6DOF 메인 팔 |
| gripper | gripper_joint (HTS-21H ×1) | - | 독립 액션 서버 |
| pan_tilt | - | - | MoveIt2 제외, 독립 토픽 제어 |

### trac-ik 설정
```yaml
arm:
  kinematics_solver: trac_ik_kinematics_plugin/TRAC_IKKinematicsPlugin
  kinematics_solver_timeout: 0.05  # 50ms
  kinematics_solver_attempts: 3
  solve_type: Speed
```

### hiwonder_bridge 변환 로직
```python
# 서보 포지션 범위: 0-1000 = 0°~240°, 중앙 500 = 120°
def radian_to_servo(radian: float) -> int:
    """라디안을 서보 포지션(0-1000)으로 변환"""
    return int(500 + math.degrees(radian) * (1000 / 240))

def servo_to_radian(position: int) -> float:
    """서보 포지션(0-1000)을 라디안으로 변환"""
    return math.radians((position - 500) * (240 / 1000))
```

---

## 버스 서보 제어 타이밍

| 버스 속도 | 서보 1개 왕복 | 9개 풀 루프 | 안정 제어 Hz |
|-----------|---------------|-------------|--------------|
| 115,200 bps (기본) | ~2ms | ~18ms | ~55Hz (여유 있음) |
| 500,000 bps (고속) | ~0.7ms | ~6.3ms | ~100Hz (최대) |
| **권장 운용 (안전 여유 포함)** | — | — | **50Hz (ros2_control update_rate)** |

⚠️ 버스 서보(HTD/HTS 계열)는 단일 TTL 라인에 데이지체인. 안정 제어는 50Hz 기준. 500kbps로 올리면 100Hz 가능하나 배선 노이즈 리스크 증가.

---

## 의존성 및 PyTorch-Free 검증

### 런타임 의존성 목록

| 구성요소 | 런타임 의존 | PyTorch-Free | 주의사항 |
|----------|-------------|--------------|----------|
| Porcupine | C SDK (pvrecorder) | ✅ 완전 | |
| Silero VAD | sherpa-onnx (내장 ORT) | ✅ 완전 | sherpa-onnx 내장 VAD 사용 시 torch import 없음 |
| moonshine STT | sherpa-onnx GPU | ✅ 완전 | glibc ≥ 2.32 필요 |
| YOLO11n | TensorRT (C++) | ✅ 완전 | export는 개발 PC에서. Jetson에는 .trt 엔진만 배포 |
| KoSimCSE | onnxruntime-gpu | ✅ 완전 | FP32 export 고정. FP16 변환 금지 |
| Piper TTS | sherpa-onnx | ✅ 완전 | |
| RapidOCR | onnxruntime-gpu | ✅ 완전 | onnxruntime-gpu 단일 설치 |
| qwen2.5 / moondream | llama.cpp (C++, CUDA) | ✅ 완전 | cmake -DGGML_CUDA=ON -DCMAKE_CUDA_ARCHITECTURES=87 |
| slam_toolbox / Nav2 / MoveIt2 | ROS2 Humble | ✅ 완전 | |
| hiwonder_bridge | rclpy | ✅ 완전 | ros_robot_controller_msgs 패키지 의존 |

### 의존성 충돌 방지
```bash
# onnxruntime 중복 방지
pip uninstall onnxruntime
pip install onnxruntime-gpu  # CUDA EP + CPU EP 통합
```

---

*JetRover AI Architecture v3.0 | Jetson Orin Nano 8GB + ROS2 Humble + 6DOF Mecanum*
